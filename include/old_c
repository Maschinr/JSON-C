#include <json.h>
#include <stdio.h>
#include <ctype.h>
#include <errno.h>


char* parse_string(unsigned int begin, const char* str, unsigned int* end) {
    const unsigned int str_length = strlen(str);
   
    for(unsigned int i = begin; i < str_length; i++) {
        if(str[i] != ' ') {
            if(str[i] == '\"') {
                i = i + 1;
                char buffer[100];
                memset(&buffer, '\0', 100);
                for(unsigned int ix = 0; ix < 100; ix++) {
                    if(str[i + ix] == '\"') { // string ended
                        *end = i + ix + 1;
                        char* res = test_malloc(sizeof(char) * strlen(buffer) + 1);
                        if(res == NULL) {
                            return NULL;
                        }
                        strcpy(res, buffer);
                        return res;
                    } else if(str[i + ix] == '\\') { //if backslash then look if valid char is after
                        if(str[i + ix + 1] == '\"') {
                            buffer[ix] = '\"';
                        } else if(str[i + ix + 1] == '\\') {
                            buffer[ix] = '\\';
                        } else if(str[i + ix + 1] == '/') {
                            buffer[ix] = '/';
                        } else if(str[i + ix + 1] == 'b') {
                            buffer[ix] = '\b';
                        } else if(str[i + ix + 1] == 'f') {
                            buffer[ix] = '\f';
                        } else if(str[i + ix + 1] == 'n') {
                            buffer[ix] = '\n';
                        } else if(str[i + ix + 1] == 'r') {
                            buffer[ix] = '\r';
                        } else if(str[i + ix + 1] == 't') {
                            buffer[ix] = '\t';
                        } else if(str[i + ix + 1] == 'u') {
                            return NULL; // TODO
                            //buffer[ix] = '\u';//todo format to hexadecimal
                        }  else {
                            return NULL;
                        }
                            
                        i = i + 1; // skip one char
                        
                    } else { // any other char add to buffer
                        buffer[ix] = str[i + ix];
                    }
                }
            } else {
                return NULL;
            }
        }
    }
}

int parse_object(unsigned int begin, const char* str, json_object* obj, unsigned int* end);

json_value* parse_value(const char* name, unsigned int begin, const char* str, unsigned int* end) {
    const unsigned int str_length = strlen(str);
    for(unsigned int i = begin; i < str_length; i++) {
        if(str[i] != ' ') {
            //Check which type of value it is
            if(str[i] == '{') { // it's an object
                json_object* obj = NULL;
                if(parse_object(i, str, obj, end) != 0) { // does not need to be freed because is held by json_value
                    //Error
                    return NULL;
                }
                return json_value_create(obj, JSON_OBJECT, name); 
            }  else if(str[i] == '[') { // it's an array

            } else if(str[i] == '\"') { // it's an string
                char* string = parse_string(i, str, end);// does not need to be freed because is held by json_value
                return json_value_create(string, JSON_STRING, name);
                //to object value
            } else if(str[i] == '-' || isdigit(str[i])) { // it's an number
                char number[100];
                memset(number, 0, 100);
                int doublevalue = 0;
                for(unsigned int ix = 0; ix + i< str_length; ix++) {
                    //go through each numbers
                    if(str[ix + i] == '.') {
                        doublevalue = 1;
                    }
                    if(str[ix + i] == '-' || isdigit(str[ix + i]) || str[ix + i] == '.' || str[ix + i] == '+') {
                        number[ix] = str[ix + i];
                    } else {
                        //end reached or error
                        *end = ix + i + 1;
                        //try to parse
                        if(doublevalue == 1) {
                            //double
                        } else {
                            //int todo long int
                            errno = 0;
                            int num_int = strtol(number, NULL, 10);
                        
                            if(errno == 0) {
                                // valid conversion
                                //create new memory for int and copy
                                int* res = test_malloc(sizeof(int));
                                memcpy(res, &num_int, sizeof(int));
                                json_value* obj = json_value_create(res, JSON_INT, name);
                               
                                return obj;
                            }
                        }
                    }
                }
            }
        }
    }
}

int parse_object(unsigned int begin, const char* str, json_object* obj, unsigned int* end) {
    //stops after parsing first object after begin
    const unsigned int str_length = strlen(str);
    if(begin > str_length) return 1;
    if(obj == NULL) return 1;
    unsigned int position = begin;
   
    for(position; position < str_length; position++) {
        if(str[position] != ' ') { // Skip whitespace
            if(str[position] == '{' || position + 1 < str_length) {
                // valid object continue
                position = position + 1; // skip cur char
                break;
            } else {
                //invalid object
                return 1;
            }
        }
    }
    //now iterate over every value aslong as } is not reached
    for(position; position < str_length; position++) {
        if(str[position] == '}') {
            //object ended
            break;
        }
        
        // Parse value('s)
        char* name = parse_string(position, str, end); // Get object name
        if(name == NULL) {
            return 1;
        }
        position = *end;
        json_value* val = parse_value(name, position, str, end);
        test_free(name);
        position = *end; 

        if(val == NULL) {
            return 1;
        }
        //Insert value into object
        json_value* ret = NULL;
        if(hashmap_get(obj->map, val->name, (void**)(&ret)) == MAP_OK) {
            return 1;
        }

        if(hashmap_put(obj->map, val->name, val) != MAP_OK) {
            //Insert errors
            json_value_free(val);
            return 1;
        }

        if(hashmap_get(obj->map, val->name, (void**)(&ret)) == MAP_OK) {
            printf("Value added %s %s\n", val->name, val->value);
        }

        
    }

    return 0;
}

json_object* json_object_from_str(const char* str) {
    
    json_object* result = json_object_create();
    unsigned int end = 0;
    if(parse_object(0, str, result, &end) != 0) {
        printf("Parsing error\n");
        json_object_free(result);
        result = NULL;
    }

    return result;
}


int json_object_value_to_str_iterator(void* cont, void* val);

typedef struct iterator_container_t {
    char** text;
    int prev_elem;
} iterator_container;

char* json_object_to_str(const json_object* object) {
    char* result;
    if(object == NULL) {
        return NULL;
    }

    if(hashmap_length(object->map) > 0) {
        result = test_malloc(sizeof(char) * 2); // {} the third for \0 will be set by hashmap_iterate
        if(result == NULL) {
            return NULL;
        }

        result[0] = '{';
        result[1] = '\0';

        iterator_container ct;
        ct.text = &result;
        ct.prev_elem = 0;

        if(hashmap_iterate(object->map, json_object_value_to_str_iterator, &ct) != MAP_OK) {
            test_free(result);
            return NULL;
        }

        void* tmp = realloc(result, strlen(result) + 2); // +2 for the \0 and the }
        if(tmp == NULL) {
            //TODO free result or is freed automatically if realloc fails?
            return NULL;
        }
        result = tmp;
        strcat(result, "}");
    } else {
        result = test_malloc(sizeof(char) * 3); // {} the third for \0 will be set by hashmap_iterate
        if(result == NULL) {
            return NULL;
        }

        result[0] = '{';
        result[1] = '}';
        result[2] = '\0';
       
    }
    return result;
}

char* json_value_to_str(json_value* value) {
    /*Create the string representation of the value*/
    char* result;
    char* value_str;
    unsigned int size;

    if(value == NULL) {
        return NULL;
    }

    if(value->name != NULL) {
        size = 4 + strlen(value->name);
    }
    
    result = NULL;
    value_str = NULL;

    switch(value->type) {
        case JSON_OBJECT: {
            value_str = json_object_to_str(*(json_object**)value->value);
            break;     
        }
        case JSON_STRING: {
            value_str = json_value_convert(value, JSON_STRING);
            char* tmp = test_malloc(strlen(value_str) + 3); // 3 for "" and \}
            memset(tmp, '\0', strlen(value_str) + 3);
            strcat(tmp, "\"");
            strcat(tmp, value_str);
            strcat(tmp, "\"\0");
            test_free(value_str);
            value_str = tmp;
            break;
        }
        default: {
            value_str = json_value_convert(value, JSON_STRING);
            break;
        }
    }
    
    size = size + strlen(value_str);
    
    result = test_malloc(sizeof(char) * size + 1);
    if(result == NULL) {
        return NULL;
    }
   

    memset(result, '\0', size);
    if(value->name != NULL) {
        result[0] = '\"';
        strcat(result, value->name);
        strcat(result, "\":");
    }
    strcat(result, value_str); // value string is null terminated so that terminates this string automatically
    test_free(value_str);
    return result;
}

//Implementation of map iterator func for parsing
int json_object_value_to_str_iterator(void* cont, void* val) {
    unsigned int size = 0;
    char* value_str = json_value_to_str((json_value*)val); // "name":value
    if(value_str == NULL) {
        return MAP_MISSING; // Error
    }
    iterator_container* ct = (iterator_container*)cont;
    size = strlen(*ct->text) + strlen(value_str);

    if(ct->prev_elem != 0) {
        size = size + 1; // For the comma
    }
    void* tmp = realloc(*ct->text, size + 1); // +1 for the \0
    if(tmp == NULL) {
        return MAP_MISSING; // Error
    }
    *ct->text = tmp;
   
    if(ct->prev_elem != 0) {
        strcat(*ct->text, ",");
    }
    strcat(*ct->text, value_str);
    test_free(value_str);
    ct->prev_elem = 1;
    return MAP_OK;
}

//Implementation for types
#define JSON_INTERNAL_MACRO(m_name, m_type, m_type_enum)\
    int json_object_add_##m_name(json_object* object, const char* name, m_type value) {\
        m_type* data;\
        json_value* element;\
        if(hashmap_get(object->map, name, (void**)(&element)) == MAP_OK) {/*Value already exists*/\
            return 1;\
        }\
\
        data = test_malloc(sizeof(m_type));\
\
        if(data == NULL) {\
            return 1;\
        }\
\
        *data = value;\
\
        json_value* val = json_value_create(data, m_type_enum, name);\
        if(val == NULL) {\
            test_free(data);\
            return 1;\
        }\
        if(hashmap_put(object->map, name, val) != MAP_OK) {\
            json_value_free(val);\
            return 1;\
        }\
\
        return 0;\
    }\

JSON_INTERNAL_TYPES

#undef JSON_INTERNAL_MACRO